rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Public university metadata (used during signup)
    match /universities/{uni} {
      // Allow anyone to read university docs and subcollections (domains, allowed_ids, departments, sections)
      allow read: if true;

      // Only super-admins or this university's admins can write university docs
      allow write: if request.auth != null &&
        (exists(/databases/$(database)/documents/super_admins/$(request.auth.uid))
         || exists(/databases/$(database)/documents/universities/$(uni)/admins/$(request.auth.uid)));

      // Timetables: allow writes by super-admins or by university/admins
      // Dept-level admins are allowed to write timetables for their dept only.
      match /timetables/{tt} {
        allow read: if true;
        allow write: if request.auth != null && (
          // super-admins can always write
          exists(/databases/$(database)/documents/super_admins/$(request.auth.uid)) ||
          // university admin document can allow uni-wide or dept-scoped admin
          (exists(/databases/$(database)/documents/universities/$(uni)/admins/$(request.auth.uid)) &&
            (
              // either the admin doc has no deptId (uni admin) OR matches the timetable's departmentId
              get(/databases/$(database)/documents/universities/$(uni)/admins/$(request.auth.uid)).data.deptId == null ||
              get(/databases/$(database)/documents/universities/$(uni)/admins/$(request.auth.uid)).data.deptId == request.resource.data.departmentId
            )
          )
        );
      }

      // Marketplace items: allow students belonging to this university to create items.
      // Admins and super-admins can create/update/delete. Owners can update/delete their own items.

      match /marketplace_items/{itemId} {
        allow read: if true;

        // Create: only allow if authenticated and one of:
        // - super-admin
        // - university admin for this university
        // - regular user whose users/{uid}.uniId matches this university AND
        //   the posted document's `uid` equals the authenticated uid
        allow create: if request.auth != null && (
          // super-admin
          exists(/databases/$(database)/documents/super_admins/$(request.auth.uid)) ||
          // university admin
          exists(/databases/$(database)/documents/universities/$(uni)/admins/$(request.auth.uid)) ||
          // regular user must belong to this university and must not impersonate another uid
          (
            get(/databases/$(database)/documents/users/$(request.auth.uid)).data.uniId == uni &&
            request.resource.data.uid == request.auth.uid
          )
        );

        // Update/delete: owner, university admin, or super-admin
        allow update, delete: if request.auth != null && (
          request.auth.uid == resource.data.uid ||
          exists(/databases/$(database)/documents/universities/$(uni)/admins/$(request.auth.uid)) ||
          exists(/databases/$(database)/documents/super_admins/$(request.auth.uid))
        );
      }

      // Other subcollections under universities follow the same permissions as before
      // Special case: ai_planner collection holds per-user AI data (chat, tasks, study)
      // Allow a user to read/write their own ai_planner doc and its subcollections
      // if their `users/{uid}.uniId` matches this university. Admins and super-admins
      // retain full access.
      match /ai_planner/{userDoc} {
        allow read: if request.auth != null && (
          request.auth.uid == userDoc ||
          exists(/databases/$(database)/documents/universities/$(uni)/admins/$(request.auth.uid)) ||
          exists(/databases/$(database)/documents/super_admins/$(request.auth.uid))
        ) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.uniId == uni;

        match /{subCollection=**} {
          allow read, write: if request.auth != null && (
            request.auth.uid == userDoc ||
            exists(/databases/$(database)/documents/universities/$(uni)/admins/$(request.auth.uid)) ||
            exists(/databases/$(database)/documents/super_admins/$(request.auth.uid))
          ) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.uniId == uni;
        }
      }

      // Other subcollections under universities follow the same permissions as before
      match /{subCollection=**} {
        allow read: if true;
        allow write: if request.auth != null &&
          (exists(/databases/$(database)/documents/super_admins/$(request.auth.uid))
           || exists(/databases/$(database)/documents/universities/$(uni)/admins/$(request.auth.uid)));
      }
    }

    // Users: allow per-doc reads for owner, super-admins, and university admins (uni-admins limited to same uni)
    match /users/{userId} {
      // allow a user to create their own doc
      allow create: if request.auth != null && request.auth.uid == userId;

      // allow reading a single user doc if:
      // - the owner, or
      // - a super-admin, or
      // - a university admin for the user's uni (checks the target doc's uniId)
      allow get: if request.auth != null && (
        request.auth.uid == userId ||
        exists(/databases/$(database)/documents/super_admins/$(request.auth.uid)) ||
        (resource.data.uniId != null &&
         exists(/databases/$(database)/documents/universities/$(resource.data.uniId)/admins/$(request.auth.uid)))
      );

      // allow listing / querying / listing all users only for super-admins
      allow list: if request.auth != null &&
        exists(/databases/$(database)/documents/super_admins/$(request.auth.uid));

      // allow updates/deletes only by owner or super-admin
      allow update, delete: if request.auth != null && (
        request.auth.uid == userId ||
        exists(/databases/$(database)/documents/super_admins/$(request.auth.uid))
      );

      // Allow authenticated users to read/write their own subcollections
      // such as chat_history and tasks. This keeps per-user data writable
      // by the account owner while preserving the stricter rules above
      // for the top-level user document.
      match /{subCollection=**} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Super-admin list: only existing super-admins can update
    match /super_admins/{uid} {
      allow read: if request.auth != null && exists(/databases/$(database)/documents/super_admins/$(request.auth.uid));
      allow write: if request.auth != null && exists(/databases/$(database)/documents/super_admins/$(request.auth.uid));
    }

    // Default: deny everything else
    // Complaints stored at root for global queries, and mirrored under universities/{uni}/complaints
    match /complaints/{complaintId} {
      // Create: only authenticated users creating complaints for their own account
      allow create: if request.auth != null
        // studentId must match caller
        && request.resource.data.studentId == request.auth.uid
        // uniId in the document must equal the user's uniId
        && request.resource.data.uniId == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.uniId;

      // Read: owner, university admins for the same uni, or super-admin
      allow read: if request.auth != null && (
        resource.data.studentId == request.auth.uid ||
        // super-admin
        exists(/databases/$(database)/documents/super_admins/$(request.auth.uid)) ||
        // university admin for the complaint's uni
        exists(/databases/$(database)/documents/universities/$(resource.data.uniId)/admins/$(request.auth.uid))
      );

      // Update: only university admins for the complaint's uni or super-admin
      allow update: if request.auth != null && (
        exists(/databases/$(database)/documents/super_admins/$(request.auth.uid)) ||
        exists(/databases/$(database)/documents/universities/$(resource.data.uniId)/admins/$(request.auth.uid))
      );

      // Delete: owner or super-admin
      allow delete: if request.auth != null && (
        resource.data.studentId == request.auth.uid ||
        exists(/databases/$(database)/documents/super_admins/$(request.auth.uid))
      );
    }

    // Jobs collection stored at root
    match /jobs/{jobId} {
      // Anyone can read active jobs
      allow read: if true;

      // Create: recruiters or super-admins (recruiterId must match caller)
      allow create: if request.auth != null && (
        request.auth.uid == request.resource.data.recruiterId ||
        exists(/databases/$(database)/documents/super_admins/$(request.auth.uid)) ||
        // university admin for job's target university
        (request.resource.data.targetUniversity != null &&
         exists(/databases/$(database)/documents/universities/$(request.resource.data.targetUniversity)/admins/$(request.auth.uid)))
      );

      // Update: recruiter owner or super-admin can update any fields.
      // Additionally allow authenticated users to ONLY increment applicantsCount by 1.
      allow update: if request.auth != null && (
        request.auth.uid == resource.data.recruiterId ||
        exists(/databases/$(database)/documents/super_admins/$(request.auth.uid)) ||
        (
          // only applicantsCount key changed and it's increment by exactly 1
          request.resource.data.keys().hasOnly(['applicantsCount']) &&
          request.resource.data.applicantsCount == resource.data.applicantsCount + 1
        )
      );

      // Delete: only recruiter owner or super-admin
      allow delete: if request.auth != null && (
        request.auth.uid == resource.data.recruiterId ||
        exists(/databases/$(database)/documents/super_admins/$(request.auth.uid))
      );
    }

    // Applications stored at root
    match /applications/{appId} {
      // Create: authenticated students may create their own application for an existing job
      allow create: if request.auth != null &&
        request.resource.data.studentId == request.auth.uid &&
        request.resource.data.jobId is string &&
        exists(/databases/$(database)/documents/jobs/$(request.resource.data.jobId)) &&
        // status must start as 'pending'
        request.resource.data.status == 'pending';

      // Read: student owner, recruiter owning the job, or super-admin
      allow read: if request.auth != null && (
        resource.data.studentId == request.auth.uid ||
        (
          resource.data.jobId is string &&
          exists(/databases/$(database)/documents/jobs/$(resource.data.jobId)) &&
          get(/databases/$(database)/documents/jobs/$(resource.data.jobId)).data.recruiterId == request.auth.uid
        ) ||
        exists(/databases/$(database)/documents/super_admins/$(request.auth.uid))
      );

      // Update: recruiter owning the job or super-admin can update status/fields
      allow update: if request.auth != null && (
        (
          resource.data.jobId is string &&
          exists(/databases/$(database)/documents/jobs/$(resource.data.jobId)) &&
          get(/databases/$(database)/documents/jobs/$(resource.data.jobId)).data.recruiterId == request.auth.uid
        ) ||
        exists(/databases/$(database)/documents/super_admins/$(request.auth.uid))
      );

      // Delete: owner (student), recruiter for job, or super-admin
      allow delete: if request.auth != null && (
        request.auth.uid == resource.data.studentId ||
        exists(/databases/$(database)/documents/super_admins/$(request.auth.uid)) ||
        (
          resource.data.jobId is string &&
          exists(/databases/$(database)/documents/jobs/$(resource.data.jobId)) &&
          get(/databases/$(database)/documents/jobs/$(resource.data.jobId)).data.recruiterId == request.auth.uid
        )
      );
    }

    // Default: deny everything else
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
